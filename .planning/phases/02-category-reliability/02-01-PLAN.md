---
phase: 02-category-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/models/categories.ts
  - hooks/useCategories.ts
  - app/(tabs)/index.tsx
autonomous: true

must_haves:
  truths:
    - "User renames a category and all existing expenses immediately show the new name"
    - "User changes a category icon and all existing expenses immediately show the new icon"
    - "Category metadata changes persist correctly across app restarts"
    - "Expense list refreshes automatically after category updates"
  artifacts:
    - path: "lib/db/models/categories.ts"
      provides: "Cascading update function for category metadata"
      exports: ["updateCustomCategoryWithCascade"]
      min_lines: 50
    - path: "hooks/useCategories.ts"
      provides: "Cache invalidation after category updates"
      contains: "onCategoryChanged callback pattern"
      min_lines: 250
    - path: "app/(tabs)/index.tsx"
      provides: "Wired refresh callback to expense list"
      contains: "onCategoryChanged.*refreshExpenses"
  key_links:
    - from: "updateCustomCategoryWithCascade"
      to: "withExclusiveTransactionAsync"
      via: "atomic multi-table update"
      pattern: "withExclusiveTransactionAsync.*UPDATE custom_categories.*UPDATE expenses"
    - from: "useCategories.updateCategory"
      to: "updateCustomCategoryWithCascade"
      via: "function call"
      pattern: "updateCustomCategoryWithCascade\\(db, id, category\\)"
    - from: "hooks/useCategories.ts"
      to: "cache invalidation callback"
      via: "onCategoryChanged trigger"
      pattern: "onCategoryChanged.*categoryId"
    - from: "app/(tabs)/index.tsx"
      to: "refreshExpenses"
      via: "onCategoryChanged callback wiring"
      pattern: "onCategoryChanged:.*refreshExpenses"
---

<objective>
Implement cascading category updates to maintain denormalized data consistency across custom_categories and expenses tables.

Purpose: When users rename categories or change icons, all associated expenses must immediately reflect the new metadata. Currently, `updateCustomCategory` only updates the custom_categories table, leaving expenses with stale denormalized data (category_name, category_icon, category_color). This causes UI inconsistencies where old expenses show outdated category information.

Output: Transactional cascading updates + cache invalidation hook pattern + parent component wiring ensuring category changes propagate to all dependent data immediately.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-category-reliability/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# Phase 1 established patterns
@.planning/phases/01-database-stabilization/01-04-SUMMARY.md

# Current implementation to extend
@lib/db/models/categories.ts
@hooks/useCategories.ts
@app/(tabs)/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cascading category update in categories model</name>
  <files>lib/db/models/categories.ts</files>
  <action>
Add new `updateCustomCategoryWithCascade` function that atomically updates both custom_categories and expenses tables when category metadata changes.

**Implementation details:**

1. Create new function signature:
```typescript
export async function updateCustomCategoryWithCascade(
  db: SQLite.SQLiteDatabase,
  id: string,
  category: Partial<CustomCategoryInput>
): Promise<CustomCategory>
```

2. Use `withExclusiveTransactionAsync` (established pattern from Phase 1) to ensure atomic multi-table updates

3. Build dynamic SQL updates for custom_categories table:
   - Only include fields that are provided (name, icon, color)
   - Always update `updated_at` timestamp
   - Use parameterized queries (security best practice)

4. Cascade changes to expenses table:
   - Build matching UPDATE for expenses WHERE category_id = ?
   - Update denormalized fields: category_name, category_icon, category_color
   - Update expenses.updated_at timestamp
   - Only execute expense UPDATE if at least one field is being changed

5. After transaction commits, fetch and return updated category (match existing pattern)

6. Error handling:
   - Input validation: category.name cannot be empty string
   - Preserve validation DatabaseErrors (re-throw as-is)
   - Handle SQLite constraint violations (codes 19, 2067) for duplicate names
   - Map other SQLite errors via `mapSQLiteErrorToUserMessage`
   - Use DatabaseError with code preservation (Phase 1 pattern)

7. DO NOT modify existing `updateCustomCategory` function - keep it for backward compatibility. The new cascading function will be called by the hook.

**Why cascading is critical:** The codebase uses denormalized category data in expenses table for query performance (avoids JOINs). When a category is renamed from "Food" to "Groceries", all 100+ existing expenses with category_id pointing to that category MUST also update their category_name field, or the UI will show "Food" on old expenses and "Groceries" on new ones.

**Reference implementation pattern from research:**
- Pattern 1 in 02-RESEARCH.md lines 62-141 shows complete cascading update example
- Follow established error handling from existing `updateCustomCategory` (lines 123-195)
- Use same transaction pattern as `deleteCustomCategory` (line 208) and `reorderCategories` (line 334)
  </action>
  <verify>
1. Run TypeScript compiler: `npx tsc --noEmit`
2. Check function exported: `grep "export.*updateCustomCategoryWithCascade" lib/db/models/categories.ts`
3. Verify transaction usage: `grep "withExclusiveTransactionAsync" lib/db/models/categories.ts | wc -l` (should be 3: delete, reorder, new cascade)
4. Verify dual UPDATE statements: `grep -A 50 "updateCustomCategoryWithCascade" lib/db/models/categories.ts | grep "UPDATE custom_categories\|UPDATE expenses" | wc -l` (should be 2)
  </verify>
  <done>
- Function `updateCustomCategoryWithCascade` exists in lib/db/models/categories.ts
- Function uses `withExclusiveTransactionAsync` for atomic multi-table updates
- Updates both custom_categories and expenses tables in single transaction
- Proper input validation and error handling with DatabaseError
- TypeScript compiles without errors
- Existing `updateCustomCategory` remains unchanged for backward compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache invalidation to useCategories hook</name>
  <files>hooks/useCategories.ts</files>
  <action>
Update `useCategories` hook to use the new cascading update function and implement cache invalidation callback pattern to refresh dependent data (expenses).

**Implementation details:**

1. Import the new cascading function:
```typescript
import {
  // ... existing imports
  updateCustomCategoryWithCascade,
} from '@/lib/db/models/categories';
```

2. Add optional callback parameter to UseCategoriesReturn interface and hook function signature:
```typescript
export interface UseCategoriesReturn {
  // ... existing fields
  onCategoryChanged?: (categoryId: string) => Promise<void>;
}

export function useCategories(
  options?: { onCategoryChanged?: (categoryId: string) => Promise<void> }
): UseCategoriesReturn {
```

3. Update `updateCategory` function (currently lines 100-132):
   - Replace call to `updateCustomCategory` with `updateCustomCategoryWithCascade`
   - After successful update and optimistic state update, trigger callback:
     ```typescript
     if (options?.onCategoryChanged) {
       await options.onCategoryChanged(id);
     }
     ```
   - Keep existing optimistic update + rollback pattern (established pattern)
   - Keep all validation (protect "Other" category, check duplicate names)

4. Update the callback dependencies array to include `options?.onCategoryChanged`

5. DO NOT change:
   - The return interface (except adding optional callback)
   - Other functions (addCategory, deleteCategory, reorderCategories)
   - Error handling patterns
   - Optimistic update + rollback on error

**Why cache invalidation matters:** After category name changes in the database (via cascade), React state in `useExpenses` hook still holds old expense data with the old category name. Without triggering a refresh, users see updated category name in the category list but old name on existing expenses until they navigate away and back.

**Pattern explanation:** This implements the "callback pattern" for cache invalidation (02-RESEARCH.md lines 148-204). The parent component (e.g., App.tsx or screen) will pass `onCategoryChanged: async (id) => { await refreshExpenses() }` to wire up the invalidation. The hook itself doesn't directly call refreshExpenses (separation of concerns - hook doesn't know what depends on categories).

**Reference:**
- Pattern 2 in 02-RESEARCH.md lines 148-179 shows complete hook callback pattern
- Existing optimistic update pattern in useCategories lines 120-128 should be preserved
- Error handling in useCategories lines 126-129 should be maintained
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Verify import: `grep "updateCustomCategoryWithCascade" hooks/useCategories.ts`
3. Verify callback in interface: `grep "onCategoryChanged" hooks/useCategories.ts`
4. Verify cascading function used: `grep "updateCustomCategoryWithCascade(db, id, category)" hooks/useCategories.ts`
5. Verify callback invoked: `grep -A 20 'updateCategory.*async' hooks/useCategories.ts | grep 'options?.onCategoryChanged'`
  </verify>
  <done>
- `useCategories` hook imports and uses `updateCustomCategoryWithCascade`
- Hook accepts optional `onCategoryChanged` callback in options parameter
- `updateCategory` function calls cascading update instead of direct update
- Callback is triggered after successful category update
- Existing optimistic update + rollback pattern preserved
- All validation and error handling maintained
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire onCategoryChanged callback in parent component</name>
  <files>app/(tabs)/index.tsx</files>
  <action>
Wire up the `onCategoryChanged` callback from `useCategories` hook to trigger expense list refresh, completing the cache invalidation chain.

**Implementation details:**

1. Locate where `useCategories` hook is called in app/(tabs)/index.tsx

2. Locate where `useExpenses` hook is called and identify the `refreshExpenses` function (or similar refresh/refetch method)

3. Wire the callback:
```typescript
const categories = useCategories({
  onCategoryChanged: async (categoryId) => {
    await refreshExpenses(); // or whatever the refresh method is called
  }
});
```

4. If `refreshExpenses` doesn't exist yet:
   - Check if `useExpenses` returns a `refresh` or `refetch` method
   - If not, the hook may auto-refresh on mount or need enhancement
   - In that case, use dependency array or state update to trigger re-render

5. Ensure the callback is properly typed (TypeScript should infer from useCategories interface)

**Why this wiring is critical:** Without this connection, the cascade updates in the database (Task 1) and the callback pattern in the hook (Task 2) would work, but the UI would not reflect changes until the user navigates away and back. The parent component is the bridge that connects category changes to expense list updates.

**Pattern explanation:** This completes the "callback pattern" chain:
1. User renames category → `useCategories.updateCategory` called
2. Hook calls `updateCustomCategoryWithCascade` → database updated
3. Hook calls `options.onCategoryChanged(categoryId)` → callback fired
4. Parent component's callback calls `refreshExpenses()` → UI refreshed
5. User sees new category name on ALL expenses immediately

**Reference:**
- Pattern 2 in 02-RESEARCH.md lines 180-204 shows parent component wiring example
- The parent component acts as the "coordinator" between independent data domains (categories and expenses)
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Verify callback wired: `grep -A 5 "useCategories" app/(tabs)/index.tsx | grep "onCategoryChanged"`
3. Verify refreshExpenses called: `grep -A 10 "onCategoryChanged" app/(tabs)/index.tsx | grep "refreshExpenses\|refresh\|refetch"`
4. Check full wiring pattern: `grep -B 2 -A 8 "useCategories" app/(tabs)/index.tsx`
  </verify>
  <done>
- `useCategories` hook called with `onCategoryChanged` callback in app/(tabs)/index.tsx
- Callback invokes expense refresh method (refreshExpenses or equivalent)
- TypeScript compiles without errors
- Category changes now trigger automatic expense list refresh
- Complete cache invalidation chain: database cascade → hook callback → parent refresh
  </done>
</task>

</tasks>

<verification>
After completion, verify category updates cascade correctly and trigger UI refresh:

1. **Compile check:**
   ```bash
   npx tsc --noEmit
   ```
   Should pass with no errors in categories.ts, useCategories.ts, or index.tsx

2. **Pattern verification:**
   ```bash
   # Verify cascading function exists
   grep -A 5 "export async function updateCustomCategoryWithCascade" lib/db/models/categories.ts

   # Verify dual UPDATE in transaction
   grep -A 60 "updateCustomCategoryWithCascade" lib/db/models/categories.ts | grep "UPDATE custom_categories\|UPDATE expenses"

   # Verify hook uses cascading function
   grep "updateCustomCategoryWithCascade(db, id, category)" hooks/useCategories.ts

   # Verify callback pattern in hook
   grep "onCategoryChanged" hooks/useCategories.ts

   # Verify parent component wiring
   grep -A 5 "useCategories" app/(tabs)/index.tsx | grep "onCategoryChanged"
   ```

3. **Transaction pattern check:**
   ```bash
   # Should show 3 uses: deleteCustomCategory, reorderCategories, updateCustomCategoryWithCascade
   grep -n "withExclusiveTransactionAsync" lib/db/models/categories.ts
   ```

4. **Integration check:**
   ```bash
   # Verify complete chain from parent to hook to model
   grep "onCategoryChanged" app/(tabs)/index.tsx hooks/useCategories.ts
   ```

All checks should pass. The implementation follows Phase 1 established patterns (exclusive transactions, DatabaseError handling, optimistic updates with rollback) and completes the cache invalidation chain from database to UI.
</verification>

<success_criteria>
Phase 02 Plan 01 is complete when:

- [ ] `updateCustomCategoryWithCascade` function exists and uses `withExclusiveTransactionAsync`
- [ ] Function updates both `custom_categories` and `expenses` tables in single transaction
- [ ] Cascading updates include category_name, category_icon, category_color fields
- [ ] `useCategories` hook calls cascading function instead of direct update
- [ ] Hook supports optional `onCategoryChanged` callback for cache invalidation
- [ ] Parent component (index.tsx) wires callback to refreshExpenses
- [ ] TypeScript compiles without errors
- [ ] Error handling follows Phase 1 DatabaseError patterns
- [ ] Existing validation and optimistic update patterns preserved
- [ ] Complete cache invalidation chain: database → hook → parent → UI refresh

**Requirements addressed:**
- CAT-01: Category rename automatically updates all associated expenses ✓ (cascading UPDATE)
- CAT-02: Category icon changes persist correctly ✓ (cascading UPDATE + atomic transaction)
- CAT-04: Category operations prevent data corruption ✓ (exclusive transaction ensures atomicity)
- UI consistency: Expense list automatically refreshes after category changes ✓ (wired callback chain)

**Ready for:**
- Phase 02 Plan 02: Position integrity validation (independent, can run in parallel)
- Phase 03: Category UX improvements (depends on reliable category operations)
</success_criteria>

<output>
After completion, create `.planning/phases/02-category-reliability/02-01-SUMMARY.md`

Summary should include:
- Performance metrics (duration, files modified)
- Accomplishments (cascading updates, cache invalidation pattern, parent wiring)
- Key decisions (why exclusive transaction, why callback pattern, why parent-level wiring)
- Files modified with specific changes
- Integration verification (category change → immediate UI update)
</output>
