---
phase: 02-category-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/models/categories.ts
  - hooks/useCategories.ts
autonomous: true

must_haves:
  truths:
    - "User renames a category and all existing expenses immediately show the new name"
    - "User changes a category icon and all existing expenses immediately show the new icon"
    - "Category metadata changes persist correctly across app restarts"
    - "Expense list refreshes automatically after category updates"
  artifacts:
    - path: "lib/db/models/categories.ts"
      provides: "Cascading update function for category metadata"
      exports: ["updateCustomCategoryWithCascade"]
      min_lines: 50
    - path: "hooks/useCategories.ts"
      provides: "Cache invalidation after category updates"
      contains: "onCategoryChanged callback pattern"
      min_lines: 250
  key_links:
    - from: "updateCustomCategoryWithCascade"
      to: "withExclusiveTransactionAsync"
      via: "atomic multi-table update"
      pattern: "withExclusiveTransactionAsync.*UPDATE custom_categories.*UPDATE expenses"
    - from: "useCategories.updateCategory"
      to: "updateCustomCategoryWithCascade"
      via: "function call"
      pattern: "updateCustomCategoryWithCascade\\(db, id, category\\)"
    - from: "hooks/useCategories.ts"
      to: "cache invalidation callback"
      via: "onCategoryChanged trigger"
      pattern: "onCategoryChanged.*categoryId"
---

<objective>
Implement cascading category updates to maintain denormalized data consistency across custom_categories and expenses tables.

Purpose: When users rename categories or change icons, all associated expenses must immediately reflect the new metadata. Currently, `updateCustomCategory` only updates the custom_categories table, leaving expenses with stale denormalized data (category_name, category_icon, category_color). This causes UI inconsistencies where old expenses show outdated category information.

Output: Transactional cascading updates + cache invalidation hook pattern ensuring category changes propagate to all dependent data immediately.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-category-reliability/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# Phase 1 established patterns
@.planning/phases/01-database-stabilization/01-04-SUMMARY.md

# Current implementation to extend
@lib/db/models/categories.ts
@hooks/useCategories.ts
@lib/db/models/expenses.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cascading category update in categories model</name>
  <files>lib/db/models/categories.ts</files>
  <action>
Add new `updateCustomCategoryWithCascade` function that atomically updates both custom_categories and expenses tables when category metadata changes.

**Implementation details:**

1. Create new function signature:
```typescript
export async function updateCustomCategoryWithCascade(
  db: SQLite.SQLiteDatabase,
  id: string,
  category: Partial<CustomCategoryInput>
): Promise<CustomCategory>
```

2. Use `withExclusiveTransactionAsync` (established pattern from Phase 1) to ensure atomic multi-table updates

3. Build dynamic SQL updates for custom_categories table:
   - Only include fields that are provided (name, icon, color)
   - Always update `updated_at` timestamp
   - Use parameterized queries (security best practice)

4. Cascade changes to expenses table:
   - Build matching UPDATE for expenses WHERE category_id = ?
   - Update denormalized fields: category_name, category_icon, category_color
   - Update expenses.updated_at timestamp
   - Only execute expense UPDATE if at least one field is being changed

5. After transaction commits, fetch and return updated category (match existing pattern)

6. Error handling:
   - Input validation: category.name cannot be empty string
   - Preserve validation DatabaseErrors (re-throw as-is)
   - Handle SQLite constraint violations (codes 19, 2067) for duplicate names
   - Map other SQLite errors via `mapSQLiteErrorToUserMessage`
   - Use DatabaseError with code preservation (Phase 1 pattern)

7. DO NOT modify existing `updateCustomCategory` function - keep it for backward compatibility. The new cascading function will be called by the hook.

**Why cascading is critical:** The codebase uses denormalized category data in expenses table for query performance (avoids JOINs). When a category is renamed from "Food" to "Groceries", all 100+ existing expenses with category_id pointing to that category MUST also update their category_name field, or the UI will show "Food" on old expenses and "Groceries" on new ones.

**Reference implementation pattern from research:**
- Pattern 1 in 02-RESEARCH.md lines 62-141 shows complete cascading update example
- Follow established error handling from existing `updateCustomCategory` (lines 123-195)
- Use same transaction pattern as `deleteCustomCategory` (line 208) and `reorderCategories` (line 334)
  </action>
  <verify>
1. Run TypeScript compiler: `npx tsc --noEmit`
2. Check function exported: `grep "export.*updateCustomCategoryWithCascade" lib/db/models/categories.ts`
3. Verify transaction usage: `grep "withExclusiveTransactionAsync" lib/db/models/categories.ts | wc -l` (should be 3: delete, reorder, new cascade)
4. Verify dual UPDATE statements: `grep -A 50 "updateCustomCategoryWithCascade" lib/db/models/categories.ts | grep "UPDATE custom_categories\|UPDATE expenses" | wc -l` (should be 2)
  </verify>
  <done>
- Function `updateCustomCategoryWithCascade` exists in lib/db/models/categories.ts
- Function uses `withExclusiveTransactionAsync` for atomic multi-table updates
- Updates both custom_categories and expenses tables in single transaction
- Proper input validation and error handling with DatabaseError
- TypeScript compiles without errors
- Existing `updateCustomCategory` remains unchanged for backward compatibility
  </done>
</task>

<task type="auto">
  <name>Task 2: Add cache invalidation to useCategories hook</name>
  <files>hooks/useCategories.ts</files>
  <action>
Update `useCategories` hook to use the new cascading update function and implement cache invalidation callback pattern to refresh dependent data (expenses).

**Implementation details:**

1. Import the new cascading function:
```typescript
import {
  // ... existing imports
  updateCustomCategoryWithCascade,
} from '@/lib/db/models/categories';
```

2. Add optional callback parameter to UseCategoriesReturn interface and hook function signature:
```typescript
export interface UseCategoriesReturn {
  // ... existing fields
  onCategoryChanged?: (categoryId: string) => Promise<void>;
}

export function useCategories(
  options?: { onCategoryChanged?: (categoryId: string) => Promise<void> }
): UseCategoriesReturn {
```

3. Update `updateCategory` function (currently lines 100-132):
   - Replace call to `updateCustomCategory` with `updateCustomCategoryWithCascade`
   - After successful update and optimistic state update, trigger callback:
     ```typescript
     if (options?.onCategoryChanged) {
       await options.onCategoryChanged(id);
     }
     ```
   - Keep existing optimistic update + rollback pattern (established pattern)
   - Keep all validation (protect "Other" category, check duplicate names)

4. Update the callback dependencies array to include `options?.onCategoryChanged`

5. DO NOT change:
   - The return interface (except adding optional callback)
   - Other functions (addCategory, deleteCategory, reorderCategories)
   - Error handling patterns
   - Optimistic update + rollback on error

**Why cache invalidation matters:** After category name changes in the database (via cascade), React state in `useExpenses` hook still holds old expense data with the old category name. Without triggering a refresh, users see updated category name in the category list but old name on existing expenses until they navigate away and back.

**Pattern explanation:** This implements the "callback pattern" for cache invalidation (02-RESEARCH.md lines 148-204). The parent component (e.g., App.tsx or screen) will pass `onCategoryChanged: async (id) => { await refreshExpenses() }` to wire up the invalidation. The hook itself doesn't directly call refreshExpenses (separation of concerns - hook doesn't know what depends on categories).

**Reference:**
- Pattern 2 in 02-RESEARCH.md lines 148-179 shows complete hook callback pattern
- Existing optimistic update pattern in useCategories lines 120-128 should be preserved
- Error handling in useCategories lines 126-129 should be maintained
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Verify import: `grep "updateCustomCategoryWithCascade" hooks/useCategories.ts`
3. Verify callback in interface: `grep "onCategoryChanged" hooks/useCategories.ts`
4. Verify cascading function used: `grep "updateCustomCategoryWithCascade(db, id, category)" hooks/useCategories.ts`
5. Verify callback invoked: `grep -A 10 "updateCustomCategoryWithCascade" hooks/useCategories.ts | grep "onCategoryChanged"`
  </verify>
  <done>
- `useCategories` hook imports and uses `updateCustomCategoryWithCascade`
- Hook accepts optional `onCategoryChanged` callback in options parameter
- `updateCategory` function calls cascading update instead of direct update
- Callback is triggered after successful category update
- Existing optimistic update + rollback pattern preserved
- All validation and error handling maintained
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After completion, verify category updates cascade correctly:

1. **Compile check:**
   ```bash
   npx tsc --noEmit
   ```
   Should pass with no errors in categories.ts or useCategories.ts

2. **Pattern verification:**
   ```bash
   # Verify cascading function exists
   grep -A 5 "export async function updateCustomCategoryWithCascade" lib/db/models/categories.ts

   # Verify dual UPDATE in transaction
   grep -A 60 "updateCustomCategoryWithCascade" lib/db/models/categories.ts | grep "UPDATE custom_categories\|UPDATE expenses"

   # Verify hook uses cascading function
   grep "updateCustomCategoryWithCascade(db, id, category)" hooks/useCategories.ts

   # Verify callback pattern
   grep "onCategoryChanged" hooks/useCategories.ts
   ```

3. **Transaction pattern check:**
   ```bash
   # Should show 3 uses: deleteCustomCategory, reorderCategories, updateCustomCategoryWithCascade
   grep -n "withExclusiveTransactionAsync" lib/db/models/categories.ts
   ```

All checks should pass. The implementation follows Phase 1 established patterns (exclusive transactions, DatabaseError handling, optimistic updates with rollback).
</verification>

<success_criteria>
Phase 02 Plan 01 is complete when:

- [ ] `updateCustomCategoryWithCascade` function exists and uses `withExclusiveTransactionAsync`
- [ ] Function updates both `custom_categories` and `expenses` tables in single transaction
- [ ] Cascading updates include category_name, category_icon, category_color fields
- [ ] `useCategories` hook calls cascading function instead of direct update
- [ ] Hook supports optional `onCategoryChanged` callback for cache invalidation
- [ ] TypeScript compiles without errors
- [ ] Error handling follows Phase 1 DatabaseError patterns
- [ ] Existing validation and optimistic update patterns preserved

**Requirements addressed:**
- CAT-01: Category rename automatically updates all associated expenses ✓ (cascading UPDATE)
- CAT-02: Category icon changes persist correctly ✓ (cascading UPDATE + atomic transaction)
- CAT-04: Category operations prevent data corruption ✓ (exclusive transaction ensures atomicity)

**Ready for:**
- Integration with UI components (parent components can wire up cache invalidation)
- Phase 02 Plan 02: Position integrity validation (independent, can run in parallel)
- Phase 03: Category UX improvements (depends on reliable category operations)
</success_criteria>

<output>
After completion, create `.planning/phases/02-category-reliability/02-01-SUMMARY.md`

Summary should include:
- Performance metrics (duration, files modified)
- Accomplishments (cascading updates, cache invalidation pattern)
- Key decisions (why exclusive transaction, why callback pattern)
- Files modified with specific changes
- Integration points for parent components to wire up refreshExpenses callback
</output>
