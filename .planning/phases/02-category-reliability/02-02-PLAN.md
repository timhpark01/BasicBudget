---
phase: 02-category-reliability
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/models/categories.ts
autonomous: true

must_haves:
  truths:
    - "Category positions are always sequential (0, 1, 2, 3...) with no gaps"
    - "Category reorder operations prevent duplicate position values"
    - "Position integrity can be validated and repaired if corruption occurs"
  artifacts:
    - path: "lib/db/models/categories.ts"
      provides: "Position validation and repair utility"
      exports: ["validateAndRepairPositions"]
      min_lines: 30
    - path: "lib/db/models/categories.ts"
      provides: "Enhanced reorderCategories with validation"
      contains: "duplicate ID validation"
      min_lines: 40
  key_links:
    - from: "reorderCategories"
      to: "duplicate validation"
      via: "input validation before transaction"
      pattern: "uniqueIds.*size.*categoryIds\\.length"
    - from: "validateAndRepairPositions"
      to: "withExclusiveTransactionAsync"
      via: "atomic renumbering"
      pattern: "withExclusiveTransactionAsync.*UPDATE.*position"
---

<objective>
Ensure category position integrity through validation, duplicate detection, and repair utilities.

Purpose: Category ordering uses integer positions (0, 1, 2, 3...). Without validation, reorder operations could create gaps (0, 1, 3, 4) or duplicates (0, 1, 1, 2) from concurrent updates or bugs. Position corruption makes ordering unpredictable and breaks drag-and-drop UI assumptions.

Output: Enhanced `reorderCategories` with duplicate detection + `validateAndRepairPositions` utility for gap/duplicate repair.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-category-reliability/02-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# Phase 1 established patterns
@.planning/phases/01-database-stabilization/01-04-SUMMARY.md

# Current implementation to enhance
@lib/db/models/categories.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add position validation and repair utility</name>
  <files>lib/db/models/categories.ts</files>
  <action>
Add `validateAndRepairPositions` utility function to detect and fix position gaps or duplicates in category ordering.

**Implementation details:**

1. Create new exported function:
```typescript
export async function validateAndRepairPositions(
  db: SQLite.SQLiteDatabase
): Promise<{ repaired: boolean; message: string }>
```

2. Load all active categories ordered by position:
```typescript
const categories = await db.getAllAsync<{ id: string; position: number }>(
  'SELECT id, position FROM custom_categories WHERE is_active = 1 ORDER BY position ASC'
);
```

3. Check if positions are sequential (0, 1, 2, 3...):
   - Use `.some()` to check if any category.position !== expected index
   - Expected sequence: `[0, 1, 2, 3, ...]` matching array indices

4. If positions are valid (no gaps/duplicates):
   - Return `{ repaired: false, message: 'Positions are valid' }`

5. If positions have gaps or duplicates:
   - Use `withExclusiveTransactionAsync` to renumber all positions atomically
   - Loop through categories array, assign position = index (0, 1, 2, 3...)
   - Update `updated_at` timestamp for each category
   - Return `{ repaired: true, message: 'Repaired N category positions' }`

6. Error handling:
   - Wrap in try-catch
   - Use DatabaseError pattern from Phase 1
   - Map SQLite errors via `mapSQLiteErrorToUserMessage`

**Why this utility matters:** Position corruption can occur from bugs, interrupted transactions, or future migrations. Having a repair function enables:
- Development mode integrity checks (log warnings if corruption detected)
- Future "Data Integrity" setting in app for users to self-repair
- Migration scripts to fix position issues after schema changes

**Reference implementation:** 02-RESEARCH.md lines 598-627 shows complete validation and repair pattern.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Function exported: `grep "export.*validateAndRepairPositions" lib/db/models/categories.ts`
3. Verify transaction used: `grep -A 30 "validateAndRepairPositions" lib/db/models/categories.ts | grep "withExclusiveTransactionAsync"`
4. Verify return type: `grep -A 5 "validateAndRepairPositions" lib/db/models/categories.ts | grep "repaired.*boolean.*message.*string"`
  </verify>
  <done>
- Function `validateAndRepairPositions` exists in lib/db/models/categories.ts
- Function detects position gaps and duplicates by comparing to expected sequence
- Uses `withExclusiveTransactionAsync` for atomic renumbering if repair needed
- Returns structured result indicating whether repair was performed
- Proper error handling with DatabaseError pattern
- TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance reorderCategories with duplicate validation</name>
  <files>lib/db/models/categories.ts</files>
  <action>
Add input validation to `reorderCategories` function to prevent duplicate category IDs in the reorder list.

**Implementation details:**

1. Locate existing `reorderCategories` function (currently lines 326-357)

2. Add duplicate detection BEFORE the transaction:
```typescript
// Validate input: ensure no duplicates
const uniqueIds = new Set(categoryIds);
if (uniqueIds.size !== categoryIds.length) {
  throw new DatabaseError(
    'Duplicate category IDs in reorder list',
    undefined,
    'validation'
  );
}
```

3. Place validation at the top of the try block, before `const now = Date.now()`

4. Keep all existing logic:
   - `withExclusiveTransactionAsync` wrapper
   - Loop through categoryIds to assign positions sequentially
   - Error handling with DatabaseError

**Why duplicate validation matters:** If UI bug or race condition passes duplicate IDs like `['cat1', 'cat2', 'cat1']`, the transaction would set:
- cat1 position = 0 (first occurrence)
- cat2 position = 1
- cat1 position = 2 (second occurrence, overwrites first)

Result: cat1 ends up at position 2, position 0 is empty (gap), and the UI shows wrong order. Validation prevents this by failing fast with clear error message.

**Pattern:** This follows "input validation before database operations" from Phase 1 (STATE.md line 53). Same pattern used in `createCustomCategory` (line 64) and `updateCustomCategory` (line 130).

**Reference:** 02-RESEARCH.md lines 217-235 shows reorderCategories with duplicate validation pattern.
  </action>
  <verify>
1. TypeScript compiles: `npx tsc --noEmit`
2. Verify validation exists: `grep -A 10 "reorderCategories" lib/db/models/categories.ts | grep "uniqueIds\|Duplicate"`
3. Verify validation before transaction: `grep -B 5 "withExclusiveTransactionAsync" lib/db/models/categories.ts | grep -A 5 "reorderCategories" | grep "uniqueIds"`
4. Check error type: `grep -A 15 "reorderCategories" lib/db/models/categories.ts | grep "DatabaseError.*Duplicate.*validation"`
  </verify>
  <done>
- `reorderCategories` function validates for duplicate category IDs before transaction
- Validation throws DatabaseError with 'validation' operation type
- Validation occurs before `withExclusiveTransactionAsync` (fail fast)
- All existing transaction logic and error handling preserved
- TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
After completion, verify position integrity features:

1. **Compile check:**
   ```bash
   npx tsc --noEmit
   ```
   Should pass with no errors in categories.ts

2. **Function exports verification:**
   ```bash
   # Verify new utility exported
   grep "export async function validateAndRepairPositions" lib/db/models/categories.ts

   # Verify reorder validation
   grep -A 15 "export async function reorderCategories" lib/db/models/categories.ts | grep "uniqueIds"
   ```

3. **Transaction usage check:**
   ```bash
   # Should now show 4 uses: delete, reorder, cascade (from 02-01), validateAndRepair
   grep -c "withExclusiveTransactionAsync" lib/db/models/categories.ts
   ```
   Should output: 4

4. **Error handling check:**
   ```bash
   # Both functions should use DatabaseError
   grep -A 5 "validateAndRepairPositions\|reorderCategories" lib/db/models/categories.ts | grep "DatabaseError"
   ```

All checks should pass. Position integrity is now enforced through validation and can be repaired if corruption occurs.
</verification>

<success_criteria>
Phase 02 Plan 02 is complete when:

- [ ] `validateAndRepairPositions` function exists and is exported
- [ ] Validation utility detects position gaps and duplicates
- [ ] Repair function uses `withExclusiveTransactionAsync` for atomic renumbering
- [ ] `reorderCategories` validates for duplicate category IDs before transaction
- [ ] Duplicate validation throws DatabaseError with clear message
- [ ] TypeScript compiles without errors
- [ ] Error handling follows Phase 1 DatabaseError patterns
- [ ] All existing reorder logic preserved

**Requirements addressed:**
- CAT-03: Category reorder maintains data consistency and position integrity ✓ (duplicate validation + repair utility)
- CAT-04: Category operations prevent data corruption ✓ (validation prevents bad input, repair fixes corruption)

**Ready for:**
- Development mode integrity checks (can call validateAndRepairPositions on startup if __DEV__)
- Future user-facing "Check Data Integrity" feature in settings
- Phase 03: Category UX improvements (reliable ordering enables better drag-and-drop UX)
</success_criteria>

<output>
After completion, create `.planning/phases/02-category-reliability/02-02-SUMMARY.md`

Summary should include:
- Performance metrics (duration, files modified)
- Accomplishments (position validation, duplicate detection)
- Key decisions (why validation before transaction, why repair utility)
- Files modified with specific changes
- Future integration points (development mode checks, user-facing integrity check)
</output>
