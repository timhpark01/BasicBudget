---
phase: 01-database-stabilization
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - lib/db/models/categories.ts
  - lib/db/models/net-worth.ts
autonomous: true

must_haves:
  truths:
    - "Category deletion is atomic (category + expense reassignment in transaction)"
    - "Category rename is atomic (category + all expenses updated together)"
    - "Net worth JSON parsing logs corruption details (not silent fallback)"
    - "Database errors preserve SQLite error codes"
  artifacts:
    - path: "lib/db/models/categories.ts"
      provides: "Category CRUD with transactions and proper error handling"
      contains: ["withExclusiveTransactionAsync", "DatabaseError"]
      min_lines: 250
    - path: "lib/db/models/net-worth.ts"
      provides: "Net worth CRUD with JSON validation and error handling"
      contains: ["DatabaseError", "JSON.parse"]
      min_lines: 150
  key_links:
    - from: "deleteCustomCategory()"
      to: "withExclusiveTransactionAsync"
      via: "wraps category delete + expense reassignment"
      pattern: "withExclusiveTransactionAsync.*async.*=>"
    - from: "renameCategory()"
      to: "withExclusiveTransactionAsync"
      via: "wraps category rename + expense updates"
      pattern: "withExclusiveTransactionAsync.*async.*=>"
    - from: "lib/db/models/net-worth.ts"
      to: "JSON.parse error handling"
      via: "catches parse errors and logs details"
      pattern: "catch.*JSON\\.parse"
---

<objective>
Update categories.ts and net-worth.ts with transactions and improved error handling.

Purpose: Add transaction boundaries to multi-step category operations (delete, rename) to prevent partial failures. Improve net-worth JSON parsing to log corruption instead of silently falling back to defaults. Use error infrastructure from Plan 01.

Output: Category operations that are atomic (all-or-nothing), and net worth operations that detect and log data corruption instead of masking it.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-database-stabilization/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

@.planning/phases/01-database-stabilization/01-01-SUMMARY.md
@lib/db/models/categories.ts
@lib/db/models/net-worth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add transactions and error handling to categories.ts</name>
  <files>lib/db/models/categories.ts</files>
  <action>
Update categories.ts with transactions for multi-step operations and improved error handling.

**Step 1: Add imports**
```typescript
import { DatabaseError, DatabaseConstraintError } from '@/lib/db/core/errors';
import { mapSQLiteErrorToUserMessage } from '@/lib/db/utils/error-mapper';
```

**Step 2: Wrap deleteCustomCategory in transaction**

Current code (lines ~190-204 based on CONCERNS.md) calls operations separately:
```typescript
// BAD: Two separate operations, app crash between them = orphaned expenses
await db.runAsync('UPDATE custom_categories SET is_active = 0 WHERE id = ?', [id]);
await reassignExpensesToCategory(db, id, defaultCategory);
```

Replace with transaction:
```typescript
export async function deleteCustomCategory(
  db: SQLite.SQLiteDatabase,
  id: string
): Promise<void> {
  try {
    await db.withExclusiveTransactionAsync(async () => {
      const now = Date.now();

      // Step 1: Soft delete category
      await db.runAsync(
        'UPDATE custom_categories SET is_active = 0, updated_at = ? WHERE id = ?',
        [now, id]
      );

      // Step 2: Reassign expenses to default "Other" category
      // (Get default category details - typically category ID "12" for Other)
      const defaultCategory = { id: '12', name: 'Other', icon: 'help-circle', color: '#666666' };
      await db.runAsync(
        `UPDATE expenses
         SET category_id = ?, category_name = ?, category_icon = ?, category_color = ?, updated_at = ?
         WHERE category_id = ?`,
        [defaultCategory.id, defaultCategory.name, defaultCategory.icon, defaultCategory.color, now, id]
      );

      // Both operations commit together or roll back together
    });
  } catch (error) {
    if (error instanceof DatabaseError) {
      throw error;
    }

    const sqliteError = error as { code?: number; message?: string };
    const userMessage = mapSQLiteErrorToUserMessage(sqliteError);

    throw new DatabaseError(
      userMessage,
      sqliteError.code,
      'delete_category',
      error as Error
    );
  }
}
```

**Step 3: Wrap renameCategory in transaction (if it exists and updates expenses)**

If there's a function that renames a category AND updates all associated expenses, wrap it in withExclusiveTransactionAsync following the same pattern.

**Step 4: Update error handling in ALL other functions**

Apply the same error handling pattern from Plan 03 to:
- createCategory
- getAllCategories
- updateCategoryPosition (already has transaction based on RESEARCH.md - just update error handling)
- Any other exported functions

**Why use withExclusiveTransactionAsync (not withTransactionAsync):**
- Exclusive transactions prevent accidental inclusion of operations from outside the transaction scope
- Critical for multi-step operations where timing matters
- Per RESEARCH.md "Pattern 3: Exclusive Transactions for Multi-Step Operations"

**What NOT to do:**
- Do NOT use manual BEGIN/COMMIT/ROLLBACK (use withExclusiveTransactionAsync)
- Do NOT change the logic of category operations (only wrap in transactions)
- Do NOT remove existing transaction in updateCategoryPosition (just improve error handling)

Follow patterns from RESEARCH.md "Pattern 3: Exclusive Transactions" and "Code Examples: Transaction-Protected Multi-Step Operation"
  </action>
  <verify>
    - File modified: lib/db/models/categories.ts
    - deleteCustomCategory uses withExclusiveTransactionAsync
    - All functions use DatabaseError pattern
    - TypeScript compiles: npx tsc --noEmit
    - Grep check: `grep -n "withExclusiveTransactionAsync" lib/db/models/categories.ts` shows at least deleteCustomCategory wrapped
  </verify>
  <done>
    - Category deletion is atomic (delete + reassign in single transaction)
    - Category rename is atomic (if function exists)
    - All category functions use proper error handling
    - Multi-step operations cannot partially fail
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve JSON validation and error handling in net-worth.ts</name>
  <files>lib/db/models/net-worth.ts</files>
  <action>
Update net-worth.ts to log JSON corruption details and use proper error handling.

**Current problem** (lines ~49-60 based on CONCERNS.md):
```typescript
try {
  const assets = JSON.parse(row.assets);
  const liabilities = JSON.parse(row.liabilities);
  return { ...row, assets, liabilities };
} catch {
  // Silent fallback masks corruption
  return { ...row, assets: [{ id: '1', name: 'Savings', amount: '0' }], liabilities: [] };
}
```
This masks data corruption without alerting anyone.

**Step 1: Add imports**
```typescript
import { DatabaseError } from '@/lib/db/core/errors';
import { mapSQLiteErrorToUserMessage } from '@/lib/db/utils/error-mapper';
```

**Step 2: Update JSON parsing with detailed logging**

In the function that reads net worth entries (likely getAllNetWorthEntries or similar):
```typescript
try {
  const assets = JSON.parse(row.assets);
  const liabilities = JSON.parse(row.liabilities);

  // Optional: Add runtime validation
  if (!Array.isArray(assets) || !Array.isArray(liabilities)) {
    console.error('⚠️  Net worth data corruption detected:', {
      entryId: row.id,
      issue: 'JSON parsed but not arrays',
      assetsType: typeof assets,
      liabilitiesType: typeof liabilities
    });
    // Still return default but log the corruption
    return {
      ...row,
      assets: [{ id: '1', name: 'Savings', amount: '0' }],
      liabilities: []
    };
  }

  return { ...row, assets, liabilities };
} catch (error) {
  // Log detailed corruption information
  console.error('⚠️  Net worth JSON corruption detected:', {
    entryId: row.id,
    rawAssets: row.assets,
    rawLiabilities: row.liabilities,
    error: (error as Error).message
  });

  // Provide user-facing warning
  console.warn('User should be notified: Net worth entry may be corrupted, showing default values');

  // Return safe defaults
  return {
    ...row,
    assets: [{ id: '1', name: 'Savings', amount: '0' }],
    liabilities: []
  };
}
```

**Step 3: Update error handling in ALL net worth functions**

Apply DatabaseError pattern to:
- createNetWorthEntry
- getNetWorthEntry
- getAllNetWorthEntries
- updateNetWorthEntry
- deleteNetWorthEntry
- Any other exported functions

Same pattern as previous tasks:
- Validate inputs before database operations
- Catch errors, check if already DatabaseError
- Map SQLite errors to user messages
- Preserve error codes via cause

**Why this approach:**
- Logs corruption details for debugging (entry ID, raw JSON)
- Provides safe fallback so app doesn't crash
- Alerts developers to data issues
- Sets up future enhancement (show warning to user)

**What NOT to do:**
- Do NOT throw errors on JSON parse failure (this would crash app on corrupt data)
- Do NOT remove the fallback defaults (users need to see something)
- Do NOT change the net worth data structure (only error handling)

Follow patterns from RESEARCH.md "Pitfall 4: JSON.parse Without Validation" and "Pattern 2: Custom Error Classes"
  </action>
  <verify>
    - File modified: lib/db/models/net-worth.ts
    - JSON parsing includes detailed error logging
    - All functions use DatabaseError pattern
    - TypeScript compiles: npx tsc --noEmit
    - Grep check: `grep -n "Net worth.*corruption" lib/db/models/net-worth.ts` shows logging added
  </verify>
  <done>
    - JSON parsing failures log detailed corruption info
    - All net worth functions use proper error handling
    - Safe fallbacks remain but with visibility
    - Error codes preserved for SQLite errors
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. TypeScript compilation: `npx tsc --noEmit`
2. Transaction check: `grep "withExclusiveTransactionAsync" lib/db/models/categories.ts` (should show deleteCustomCategory and possibly rename)
3. Error handling check: `grep "DatabaseError" lib/db/models/{categories,net-worth}.ts` (should show imports and usage)
4. JSON logging check: `grep "corruption" lib/db/models/net-worth.ts` (should show detailed logging)
</verification>

<success_criteria>
- [ ] Category deletion uses atomic transaction (delete + reassign)
- [ ] Category rename uses atomic transaction (if function exists)
- [ ] JSON parsing failures log entry ID and raw data
- [ ] All functions in both files use DatabaseError pattern
- [ ] Multi-step operations cannot leave database in inconsistent state
- [ ] TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-stabilization/01-04-SUMMARY.md`
</output>
