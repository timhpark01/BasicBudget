---
phase: 01-database-stabilization
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/db/models/expenses.ts
  - lib/db/models/budgets.ts
  - lib/db/models/category-budgets.ts
autonomous: true

must_haves:
  truths:
    - "Database errors preserve original SQLite error codes"
    - "Constraint violations show actionable messages (not generic failures)"
    - "Validation errors throw before database operations"
  artifacts:
    - path: "lib/db/models/expenses.ts"
      provides: "Expense CRUD with proper error handling"
      contains: "DatabaseError"
      min_lines: 150
    - path: "lib/db/models/budgets.ts"
      provides: "Budget CRUD with proper error handling"
      contains: "DatabaseError"
      min_lines: 100
    - path: "lib/db/models/category-budgets.ts"
      provides: "Category budget CRUD with proper error handling"
      contains: "DatabaseError"
      min_lines: 100
  key_links:
    - from: "lib/db/models/expenses.ts"
      to: "lib/db/core/errors.ts"
      via: "imports and throws DatabaseError"
      pattern: "import.*DatabaseError.*from.*errors"
    - from: "lib/db/models/budgets.ts"
      to: "lib/db/utils/error-mapper.ts"
      via: "maps SQLite errors to user messages"
      pattern: "mapSQLiteErrorToUserMessage"
---

<objective>
Update database models (expenses, budgets, category-budgets) with proper error handling.

Purpose: Replace generic "Please try again" error messages with actionable feedback that preserves SQLite error context. Use custom error classes from Plan 01 to enable intelligent error recovery and user guidance.

Output: Three database models with consistent error handling pattern - validate inputs early, preserve error context, provide actionable messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-database-stabilization/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

@.planning/phases/01-database-stabilization/01-01-SUMMARY.md
@lib/db/models/expenses.ts
@lib/db/models/budgets.ts
@lib/db/models/category-budgets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update expenses.ts error handling</name>
  <files>lib/db/models/expenses.ts</files>
  <action>
Update all error handling in expenses.ts to use custom error classes and preserve SQLite error context.

**Current anti-pattern** (appears in all functions):
```typescript
} catch (error) {
  console.error('Failed to create expense:', error);
  throw new Error('Failed to create expense. Please try again.');
}
```
This loses the original error code and makes debugging impossible.

**Update pattern** (apply to ALL functions):

1. **Add imports at top of file:**
   ```typescript
   import { DatabaseError, DatabaseConstraintError } from '@/lib/db/core/errors';
   import { mapSQLiteErrorToUserMessage } from '@/lib/db/utils/error-mapper';
   ```

2. **For each function with try-catch:**
   - Add input validation BEFORE database operation (fail fast)
   - Replace generic error throwing with typed errors
   - Preserve original error as `cause`
   - Use error mapper for user-facing messages

**Example - createExpense function:**
```typescript
export async function createExpense(db: SQLite.SQLiteDatabase, expense: ExpenseInput): Promise<Expense> {
  try {
    // Input validation (fail fast)
    if (!expense.category) {
      throw new DatabaseError('Category is required', undefined, 'validation');
    }
    const amountNum = parseFloat(expense.amount);
    if (isNaN(amountNum) || amountNum <= 0) {
      throw new DatabaseError('Amount must be a positive number', undefined, 'validation');
    }

    // ... existing database operation ...

  } catch (error) {
    // If already a DatabaseError (validation), re-throw as-is
    if (error instanceof DatabaseError) {
      throw error;
    }

    // Map SQLite errors to user messages
    const sqliteError = error as { code?: number; message?: string };
    const userMessage = mapSQLiteErrorToUserMessage(sqliteError);

    throw new DatabaseError(
      userMessage,
      sqliteError.code,
      'create_expense',
      error as Error
    );
  }
}
```

**Apply to all functions in expenses.ts:**
- createExpense
- getAllExpenses
- getExpensesByMonth
- getExpensesByDateRange
- updateExpense
- deleteExpense
- deleteAllExpenses

**What NOT to do:**
- Do NOT remove console.error completely (keep for unexpected errors in catch)
- Do NOT change function signatures or return types
- Do NOT add new validation rules beyond what exists (this is error handling, not feature work)
- Do NOT remove existing try-catch blocks (we're improving them, not removing)

Follow patterns from RESEARCH.md "Pattern 2: Custom Error Classes" and "Code Examples: Error Handling with Actionable Messages"
  </action>
  <verify>
    - File modified: lib/db/models/expenses.ts
    - Imports added: DatabaseError, mapSQLiteErrorToUserMessage
    - All catch blocks use custom error classes
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    - All expense functions throw DatabaseError with preserved context
    - Input validation happens before database operations
    - SQLite errors map to actionable user messages
    - Error codes preserved for debugging
  </done>
</task>

<task type="auto">
  <name>Task 2: Update budgets.ts error handling</name>
  <files>lib/db/models/budgets.ts</files>
  <action>
Update all error handling in budgets.ts with same pattern as expenses.ts.

**Same pattern as Task 1, apply to:**
- createBudget
- getBudgetByMonth
- updateBudget
- deleteBudget
- getAllBudgets
- Any other exported functions

**Budget-specific validation to add:**
- Budget amount must be positive number
- Month must be valid integer (0-11)
- Year must be valid 4-digit number

**Example validation for createBudget:**
```typescript
if (isNaN(parseFloat(amount)) || parseFloat(amount) <= 0) {
  throw new DatabaseError('Budget amount must be a positive number', undefined, 'validation');
}
if (month < 0 || month > 11) {
  throw new DatabaseError('Month must be between 0 and 11', undefined, 'validation');
}
if (year < 1970 || year > 2100) {
  throw new DatabaseError('Year must be a valid 4-digit number', undefined, 'validation');
}
```

**Follow same pattern:**
1. Add imports (DatabaseError, mapSQLiteErrorToUserMessage)
2. Add input validation before database ops
3. Replace catch blocks with typed error handling
4. Preserve original error as cause

Do NOT change the logic of budget operations, only error handling.
  </action>
  <verify>
    - File modified: lib/db/models/budgets.ts
    - All functions use DatabaseError pattern
    - Input validation added for budget-specific rules
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    - All budget functions throw DatabaseError with context
    - Budget-specific validation (amount, month, year)
    - Error handling consistent with expenses.ts pattern
  </done>
</task>

<task type="auto">
  <name>Task 3: Update category-budgets.ts error handling</name>
  <files>lib/db/models/category-budgets.ts</files>
  <action>
Update all error handling in category-budgets.ts with same pattern.

**Apply to all functions:**
- createCategoryBudget
- getCategoryBudget
- getAllCategoryBudgets
- updateCategoryBudget
- deleteCategoryBudget
- Any other exported functions

**Category budget specific validation:**
- Category ID required and not empty string
- Amount must be positive number
- Month/year validation (same as budgets.ts)

**Same pattern:**
1. Add imports
2. Input validation first
3. Replace catch blocks with DatabaseError
4. Preserve error codes and context

**Note:** This file may already use some transactions (category reordering). Do NOT remove or modify transaction logic - only update error handling within try-catch blocks.
  </action>
  <verify>
    - File modified: lib/db/models/category-budgets.ts
    - All functions use DatabaseError pattern
    - Existing transaction logic preserved
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    - All category budget functions use proper error handling
    - Validation for category ID, amount, month, year
    - Error codes and context preserved
    - Transaction logic untouched
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. TypeScript compilation: `npx tsc --noEmit`
2. Grep check for old pattern: `grep -r "console.error.*throw new Error" lib/db/models/{expenses,budgets,category-budgets}.ts` (should find none in updated files)
3. Grep check for new pattern: `grep -r "DatabaseError" lib/db/models/{expenses,budgets,category-budgets}.ts` (should find imports and usage)
4. Import check: All three files import from @/lib/db/core/errors and @/lib/db/utils/error-mapper
</verification>

<success_criteria>
- [ ] All three model files use DatabaseError consistently
- [ ] Input validation happens before database operations
- [ ] Original SQLite error codes preserved via cause property
- [ ] User-facing messages come from error mapper (actionable)
- [ ] No generic "Please try again" messages remain in these files
- [ ] TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-stabilization/01-03-SUMMARY.md`
</output>
