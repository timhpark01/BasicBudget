---
phase: 01-database-stabilization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/core/database.ts
autonomous: false

must_haves:
  truths:
    - "Concurrent calls to getDatabase() return the same instance"
    - "Database initialization happens exactly once even under race conditions"
    - "Initialization promise is not cleared before instance is set"
  artifacts:
    - path: "lib/db/core/database.ts"
      provides: "Race-condition-free singleton pattern"
      contains: "isInitializing"
      min_lines: 180
  key_links:
    - from: "getDatabase()"
      to: "isInitializing flag"
      via: "mutex check before creating promise"
      pattern: "if.*isInitializing.*initializationPromise"
    - from: "initializationPromise"
      to: "databaseInstance"
      via: "instance set before promise cleared"
      pattern: "databaseInstance.*=.*await.*initializationPromise"
---

<objective>
Fix race condition in database singleton initialization.

Purpose: Prevent multiple concurrent calls to getDatabase() from creating duplicate initialization attempts. The current implementation has a race condition where initializationPromise is cleared in the finally block before databaseInstance is set, allowing a second call to start initialization.

Output: Singleton pattern with mutex lock that guarantees single initialization even under concurrent access.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-database-stabilization/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

@lib/db/core/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mutex lock to singleton pattern</name>
  <files>lib/db/core/database.ts</files>
  <action>
Fix the race condition in getDatabase() singleton pattern by adding a mutex flag.

**Current problem** (lines 157-178):
```typescript
export async function getDatabase(): Promise<SQLite.SQLiteDatabase> {
  if (databaseInstance) {
    return databaseInstance;
  }
  if (initializationPromise) {
    return initializationPromise;
  }
  initializationPromise = initDatabase();
  try {
    databaseInstance = await initializationPromise;
    return databaseInstance;
  } finally {
    initializationPromise = null; // ‚ö†Ô∏è RACE: Cleared before instance is set!
  }
}
```

**The race:** JavaScript's async/await allows finally to execute before the try block completes setting databaseInstance. If timing is off, a second call sees initializationPromise === null and starts a new initialization.

**Fix steps:**

1. Add mutex flag at top of file (after initializationPromise declaration):
   ```typescript
   let isInitializing = false;
   ```

2. Update getDatabase() to use mutex pattern from RESEARCH.md "Pattern 1: Singleton Database with Mutex Lock":
   - Check isInitializing before creating new promise
   - Set isInitializing = true BEFORE creating initializationPromise
   - Set isInitializing = false in finally block AFTER clearing promise
   - On error, clear databaseInstance to allow retry

**Complete implementation:**
```typescript
export async function getDatabase(): Promise<SQLite.SQLiteDatabase> {
  if (databaseInstance) {
    return databaseInstance;
  }

  // Wait for any in-progress initialization
  if (isInitializing && initializationPromise) {
    return initializationPromise;
  }

  // Set mutex before creating promise
  isInitializing = true;
  initializationPromise = initDatabase();

  try {
    databaseInstance = await initializationPromise;
    return databaseInstance;
  } catch (error) {
    // On failure, clear instance so retry is possible
    databaseInstance = null;
    throw error;
  } finally {
    // Clear promise AFTER setting instance/error
    initializationPromise = null;
    isInitializing = false;
  }
}
```

**Why this fixes the race:**
- isInitializing prevents second call from creating new promise while first is in progress
- Instance is set before finally block executes
- Error case clears instance to allow retry (prevents infinite failure state)

**What NOT to do:**
- Do NOT use setTimeout or manual retry logic (SQLite has built-in busy handling)
- Do NOT change initDatabase() function (issue is in getDatabase)
- Do NOT remove error re-throw (errors must propagate to caller)
  </action>
  <verify>
    - File modified: lib/db/core/database.ts
    - New variable added: let isInitializing = false
    - getDatabase() updated with mutex pattern
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    - Mutex flag isInitializing added
    - getDatabase() checks isInitializing before creating promise
    - Finally block clears both promise and flag in correct order
    - Error case clears instance to allow retry
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Database singleton with race-condition-free initialization.
  </what-built>
  <how-to-verify>
**Manual verification steps:**

1. **Start the app in Expo** (this triggers database initialization):
   ```bash
   npx expo start
   ```

2. **Check console logs** for single initialization:
   - Should see exactly ONE "üîÑ Initializing database..." message on app launch
   - Should NOT see multiple initialization messages
   - Should NOT see "Table already exists" errors

3. **Force re-initialization** by reloading app multiple times:
   - In Expo Go: Shake device ‚Üí Reload
   - In web: Refresh browser multiple times rapidly
   - In simulator: Cmd+R repeatedly

4. **Expected behavior:**
   - Console shows single initialization per reload
   - No duplicate initialization attempts
   - No race condition warnings in logs

5. **Test edge case - rapid navigation:**
   - Open app ‚Üí immediately navigate between tabs (Index, Charts, More)
   - This triggers multiple hooks simultaneously calling getDatabase()
   - Verify: Still only one initialization message

**Signs of success:**
- ‚úÖ Single "üîÑ Initializing database..." per app launch
- ‚úÖ No "Table already exists" migration errors
- ‚úÖ Fast tab switching doesn't trigger re-initialization

**Signs of failure:**
- ‚ùå Multiple initialization messages on single launch
- ‚ùå Migration errors about existing tables
- ‚ùå Database-related errors in console
  </how-to-verify>
  <resume-signal>
Type "approved" if initialization works correctly, or describe any issues observed.
  </resume-signal>
</task>

</tasks>

<verification>
After Task 1 completion:
1. Code review: Verify isInitializing flag exists and is checked before creating promise
2. TypeScript compilation: `npx tsc --noEmit`
3. Pattern match: Code follows RESEARCH.md "Pattern 1: Singleton Database with Mutex Lock"

After Task 2 (checkpoint):
1. Functional verification via Expo app testing
2. Log analysis confirms single initialization
3. Rapid reload/navigation testing shows no race conditions
</verification>

<success_criteria>
- [ ] isInitializing mutex flag prevents duplicate initialization attempts
- [ ] getDatabase() returns same instance for concurrent calls
- [ ] App launch logs show single database initialization
- [ ] Rapid navigation/reloads do not trigger multiple initializations
- [ ] Error case allows retry (instance cleared on failure)
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-stabilization/01-02-SUMMARY.md`
</output>
