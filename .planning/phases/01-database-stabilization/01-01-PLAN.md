---
phase: 01-database-stabilization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/core/errors.ts
  - lib/db/utils/error-mapper.ts
autonomous: true

must_haves:
  truths:
    - "Database errors preserve original SQLite error codes"
    - "Error messages are type-safe with custom error classes"
    - "SQLite error codes map to actionable user messages"
  artifacts:
    - path: "lib/db/core/errors.ts"
      provides: "Custom error class hierarchy"
      exports: ["DatabaseError", "DatabaseConstraintError", "DatabaseLockError"]
      min_lines: 40
    - path: "lib/db/utils/error-mapper.ts"
      provides: "SQLite error code to user message mapping"
      exports: ["mapSQLiteErrorToUserMessage"]
      min_lines: 30
  key_links:
    - from: "lib/db/core/errors.ts"
      to: "TypeScript Error class"
      via: "extends Error with proper prototype chain"
      pattern: "Object\\.setPrototypeOf"
    - from: "lib/db/utils/error-mapper.ts"
      to: "lib/db/core/errors.ts"
      via: "imports error classes"
      pattern: "import.*DatabaseError.*from.*errors"
---

<objective>
Create foundational error infrastructure for database operations.

Purpose: Provide type-safe error handling that preserves SQLite error context and provides actionable user messages. This enables all database models to throw meaningful errors instead of generic "Please try again" messages.

Output: Custom error classes and error mapping utility that subsequent plans will use to improve error handling across all database models.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-database-stabilization/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md
@.planning/codebase/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom error classes</name>
  <files>lib/db/core/errors.ts</files>
  <action>
Create TypeScript error class hierarchy for database errors following ES2022 error handling best practices.

**Create lib/db/core/errors.ts with:**

1. **Base DatabaseError class** with:
   - message: string
   - code?: string | number (SQLite error code)
   - operation?: string (what operation failed)
   - cause?: Error (original error - preserves stack trace)
   - Proper prototype chain fix: Object.setPrototypeOf(this, DatabaseError.prototype)

2. **DatabaseConstraintError** extending DatabaseError with:
   - constraintType: 'unique' | 'foreign_key' | 'not_null' | 'check'
   - Auto-sets operation to 'constraint_violation'

3. **DatabaseLockError** extending DatabaseError with:
   - Auto-sets operation to 'database_locked'

**Why this approach:**
- Preserves original error as `cause` instead of losing it with console.error + throw new Error
- Type-safe error handling with instanceof checks
- Enables specific error recovery strategies (retry on lock, show constraint message to user)

**What to avoid:**
- Do NOT use console.error to log errors in constructors (errors should be logged at catch site)
- Do NOT throw generic Error objects (defeats the purpose of custom classes)
- Do NOT forget Object.setPrototypeOf() - required for instanceof to work with TypeScript class inheritance

Follow patterns from RESEARCH.md "Pattern 2: Custom Error Classes with SQLite Context"
  </action>
  <verify>
    - File exists: lib/db/core/errors.ts
    - All three error classes export correctly
    - TypeScript compiles without errors: npx tsc --noEmit
  </verify>
  <done>
    - DatabaseError base class with code, operation, cause properties
    - DatabaseConstraintError with constraintType property
    - DatabaseLockError ready for use
    - All classes have proper prototype chain for instanceof checks
  </done>
</task>

<task type="auto">
  <name>Task 2: Create error mapping utility</name>
  <files>lib/db/utils/error-mapper.ts</files>
  <action>
Create utility to map SQLite error codes to actionable user messages.

**Create lib/db/utils/error-mapper.ts with:**

Function: `mapSQLiteErrorToUserMessage(error: any): string`

**Map these SQLite error codes** (from RESEARCH.md "Pattern 4: Actionable Error Messages"):
- Code 5 (SQLITE_BUSY): "Database is busy. Please wait a moment and try again."
- Code 261 (SQLITE_BUSY_RECOVERY): Same as above
- Code 19 (SQLITE_CONSTRAINT): "This operation would create duplicate data. Please check your input."
- Code 2067 (SQLITE_CONSTRAINT_UNIQUE): "An entry with this information already exists."
- Code 13 (SQLITE_FULL): "Device storage is full. Please free up space and try again."
- Code 11 (SQLITE_CORRUPT): "Database error detected. Please contact support."
- Code 7 (SQLITE_NOMEM): "Not enough memory available. Please close other apps and try again."
- Default: "An unexpected error occurred. Please try again." (with console.error logging the unmapped code)

**Implementation notes:**
- Accept error as `any` type (SQLite errors don't have guaranteed type)
- Extract code from error?.code
- Handle both primary codes (5, 19) and extended codes (261, 2067)
- Log unmapped errors with: `console.error('Unmapped SQLite error:', code, error.message)`

**Why this approach:**
- Provides immediate user value by translating technical errors
- Logs unmapped codes to discover new error scenarios
- Single source of truth for error message mapping

Follow patterns from RESEARCH.md "Pattern 4: Actionable Error Messages"
  </action>
  <verify>
    - File exists: lib/db/utils/error-mapper.ts
    - Function exports correctly
    - TypeScript compiles: npx tsc --noEmit
  </verify>
  <done>
    - mapSQLiteErrorToUserMessage function created
    - All 7+ SQLite error codes mapped to user messages
    - Default case logs unmapped errors for debugging
    - Function ready for use in database models
  </done>
</task>

</tasks>

<verification>
After completing both tasks:
1. TypeScript compilation: `npx tsc --noEmit` (should pass)
2. Error classes can be imported: `import { DatabaseError } from '@/lib/db/core/errors'`
3. Error mapper can be imported: `import { mapSQLiteErrorToUserMessage } from '@/lib/db/utils/error-mapper'`
4. No runtime dependencies on database (pure TypeScript utilities)
</verification>

<success_criteria>
- [ ] Custom error classes preserve original error information via `cause` property
- [ ] Error classes support instanceof checks (proper prototype chain)
- [ ] SQLite error codes map to actionable user messages
- [ ] All TypeScript compilation passes
- [ ] Error infrastructure ready for use in Plans 03 and 04
</success_criteria>

<output>
After completion, create `.planning/phases/01-database-stabilization/01-01-SUMMARY.md`
</output>
